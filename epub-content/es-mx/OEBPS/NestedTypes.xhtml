<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
  	<link href="epub.css" media="all" rel="stylesheet" type="text/css" />
  	<script type="text/javascript" src="svg.js"></script>
  </head>
  <body id="conceptual_flow_with_tasks">
    <div class="content-wrapper">
      <div id="chapter_container" class='conceptualwithtasks'>
  <article class="chapter">
    <a id="TP40016643-CH23">&#x200c;</a><a id="TP40016643-CH23-ID242">&#x200c;</a>
      
    <h2 class="chapter-name">Tipos Anidados</h2>
      	<section class="section">
      		<p class="para">Enumeraciones son a menudo creadas para respaldar una clase específica o la funcionalidad de una estructura. De la misma manera, puede ser conveniente definir clases de utilidad y estructuras puramente para usar dentro del contexto de un tipo más complejo. Para lograr esto, Swift permite definir <em>tipos anidados</em>, donde puedes anidar enumeraciones, clases y estructuras dentro de la definición del tipo que soportan.</p><p class="para">Para anidar un tipo dentro de otro, escribe su definición dentro de las llaves exteriores del tipo que soporta. Tipos pueden ser anidados a tantos niveles como sea requerido.</p>
    		</section>


      <section class="section">
	<a id="TP40016643-CH23-ID243">&#x200c;</a>
  
  <h3 class="section-name">Tipos Anidados en Acción</h3>
  <p class="para">El ejemplo de abajo define una estructura llamada <code class="code-voice">BlackjackCard</code>, el cual modela una carta como se usa en el juego de Blackjack. La estructura <code class="code-voice">BlackJack</code> contiene dos tipos de enumeraciones anidadas llamadas <code class="code-voice">Suit</code> y <code class="code-voice">Rank</code>.</p><p class="para">En Blackjack, las cartas del As tienen un valor de uno u once. Esta característica es representada por una estructura llamada <code class="code-voice">Values</code>, la cual está anidada dentro de la enumeración <code class="code-voice">Rank</code>:</p><section class="code-listing">
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">struct</code> <code class="vc">BlackjackCard</code> {</code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <code class="c">// nested Suit enumeration</code></code></li>
            <li><code class="code-voice">    <code class="kt">enum</code> <code class="vc">Suit</code>: <code class="n"><!-- a href="" logicalPath="" -->Character<!-- /a --></code> {</code></li>
            <li><code class="code-voice">        <code class="kt">case</code> <code class="vc">Spades</code> = <code class="s">&quot;♠&quot;</code>, <code class="vc">Hearts</code> = <code class="s">&quot;♡&quot;</code>, <code class="vc">Diamonds</code> = <code class="s">&quot;♢&quot;</code>, <code class="vc">Clubs</code> = <code class="s">&quot;♣&quot;</code></code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <code class="c">// nested Rank enumeration</code></code></li>
            <li><code class="code-voice">    <code class="kt">enum</code> <code class="vc">Rank</code>: <code class="n"><!-- a href="" logicalPath="" -->Int<!-- /a --></code> {</code></li>
            <li><code class="code-voice">        <code class="kt">case</code> <code class="vc">Two</code> = <code class="m">2</code>, <code class="vc">Three</code>, <code class="vc">Four</code>, <code class="vc">Five</code>, <code class="vc">Six</code>, <code class="vc">Seven</code>, <code class="vc">Eight</code>, <code class="vc">Nine</code>, <code class="vc">Ten</code></code></li>
            <li><code class="code-voice">        <code class="kt">case</code> <code class="vc">Jack</code>, <code class="vc">Queen</code>, <code class="vc">King</code>, <code class="vc">Ace</code></code></li>
            <li><code class="code-voice">        <code class="kt">struct</code> <code class="vc">Values</code> {</code></li>
            <li><code class="code-voice">            <code class="kt">let</code> <code class="vc">first</code>: <code class="n"><!-- a href="" logicalPath="" -->Int<!-- /a --></code>, <code class="vc">second</code>: <code class="n"><!-- a href="" logicalPath="" -->Int<!-- /a --></code>?</code></li>
            <li><code class="code-voice">        }</code></li>
            <li><code class="code-voice">        <code class="kt">var</code> <code class="vc">values</code>: <code class="n"><!-- a href="" logicalPath="" -->Values<!-- /a --></code> {</code></li>
            <li><code class="code-voice">            <code class="kt">switch</code> <code class="kt">self</code> {</code></li>
            <li><code class="code-voice">            <code class="kt">case</code> .<code class="vc">Ace</code>:</code></li>
            <li><code class="code-voice">                <code class="kt">return</code> <code class="vc">Values</code>(<code class="vc">first</code>: <code class="m">1</code>, <code class="vc">second</code>: <code class="m">11</code>)</code></li>
            <li><code class="code-voice">            <code class="kt">case</code> .<code class="vc">Jack</code>, .<code class="vc">Queen</code>, .<code class="vc">King</code>:</code></li>
            <li><code class="code-voice">                <code class="kt">return</code> <code class="vc">Values</code>(<code class="vc">first</code>: <code class="m">10</code>, <code class="vc">second</code>: <code class="kt">nil</code>)</code></li>
            <li><code class="code-voice">            <code class="kt">default</code>:</code></li>
            <li><code class="code-voice">                <code class="kt">return</code> <code class="vc">Values</code>(<code class="vc">first</code>: <code class="kt">self</code>.<code class="vc">rawValue</code>, <code class="vc">second</code>: <code class="kt">nil</code>)</code></li>
            <li><code class="code-voice">            }</code></li>
            <li><code class="code-voice">        }</code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">    </code></li>
            <li><code class="code-voice">    <code class="c">// BlackjackCard properties and methods</code></code></li>
            <li><code class="code-voice">    <code class="kt">let</code> <code class="vc">rank</code>: <code class="n"><!-- a href="" logicalPath="" -->Rank<!-- /a --></code>, <code class="vc">suit</code>: <code class="n"><!-- a href="" logicalPath="" -->Suit<!-- /a --></code></code></li>
            <li><code class="code-voice">    <code class="kt">var</code> <code class="vc">description</code>: <code class="n"><!-- a href="" logicalPath="" -->String<!-- /a --></code> {</code></li>
            <li><code class="code-voice">        <code class="kt">var</code> <code class="vc">output</code> = <code class="s">&quot;suit is </code>\(<code class="vc">suit</code>.<code class="vc">rawValue</code>)<code class="s">,&quot;</code></code></li>
            <li><code class="code-voice">        <code class="vc">output</code> += <code class="s">&quot; value is </code>\(<code class="vc">rank</code>.<code class="vc">values</code>.<code class="vc">first</code>)<code class="s">&quot;</code></code></li>
            <li><code class="code-voice">        <code class="kt">if</code> <code class="kt">let</code> <code class="vc">second</code> = <code class="vc">rank</code>.<code class="vc">values</code>.<code class="vc">second</code> {</code></li>
            <li><code class="code-voice">            <code class="vc">output</code> += <code class="s">&quot; or </code>\(<code class="vc">second</code>)<code class="s">&quot;</code></code></li>
            <li><code class="code-voice">        }</code></li>
            <li><code class="code-voice">        <code class="kt">return</code> <code class="vc">output</code></code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
        </ol>
      </div>
  </div>
  
</section><p class="para">La enumeración <code class="code-voice">Suit</code> describe los cuatro juegos comunes de carta junto con un valor crudo <code class="code-voice">Character</code> para representar su símbolo.</p><p class="para">La enumeración <code class="code-voice">Rank</code> describe los trece posibles rangos de cartas junto con un valor <code class="code-voice">Int</code> para representar su valor frontal. (Este valor crudo <code class="code-voice">Int</code> no es usado para las cartas Jota, Reina, Rey, ni el As.)</p><p class="para">Como se menciona arriba, la enumeración <code class="code-voice">Rank</code> define una estructura anidada adicional llamada <code class="code-voice">Values</code>. Esta estructura encapsula el hecho de que la mayoría de cartas tienen un valor, excepto el As que tiene dos valores. La estructura <code class="code-voice">Values</code> define dos propiedades para representar lo anterior:</p><ul class="list-bullet">
  <li class="item"><p class="para"><code class="code-voice">first</code>, de tipo <code class="code-voice">Int</code></p></li><li class="item"><p class="para"><code class="code-voice">second</code>, de tipo <code class="code-voice">Int?</code>, o “<code class="code-voice">Int</code> opcional”</p></li>
</ul><p class="para"><code class="code-voice">Rank</code> también define una propiedad computada, <code class="code-voice">values</code>, la cual regresa una instancia de la estructura <code class="code-voice">Values</code>. Esta propiedad computada considera el rango de la carta e inicializa una nueva instancia de <code class="code-voice">Values</code> con valores apropiados basados en su rango. Usa valores especiales para <code class="code-voice">Jack</code>, <code class="code-voice">Queen</code>, <code class="code-voice">King</code> y <code class="code-voice">Ace</code>. Para las cartas numéricas, usa el valor crudo de rank <code class="code-voice">Int</code>.</p><p class="para">La estructura <code class="code-voice">BlackjackCard</code> a si mismo tiene dos propiedades—<code class="code-voice">rank</code> y <code class="code-voice">suit</code>. También define una propiedad computada llamada <code class="code-voice">description</code>, la cual usa valores almacenados en <code class="code-voice">rank</code> y <code class="code-voice">suit</code> para construir una descripción del nombre y valor de la carta. La propiedad <code class="code-voice">description</code> usa un enlace opcional para checar si hay un segundo valor para mostrar, y si es así, inserta detalles adicionales para el segundo valor.</p><p class="para">Debido a que <code class="code-voice">BlackjackCard</code> es una estructura que no tiene inicializadores personalizados, tiene un inicializador the miembros implícito, como se describe en <a rel="me" data-id="//apple_ref/doc/uid/TP40016643-CH18-ID214" href="Initialization.xhtml#TP40016643-CH18-ID214">Inicializador de Miembros para Tipos de Estructura</a>. Tu puedes usar este inicializador para inicializar una nueva constante llamada <code class="code-voice">theAceOfSpades</code>:</p><section class="code-listing">
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">theAceOfSpades</code> = <code class="vc">BlackjackCard</code>(<code class="vc">rank</code>: .<code class="vc">Ace</code>, <code class="vc">suit</code>: .<code class="vc">Spades</code>)</code></li>
            <li><code class="code-voice"><code class="vc">print</code>(<code class="s">&quot;theAceOfSpades: </code>\(<code class="vc">theAceOfSpades</code>.<code class="vc">description</code>)<code class="s">&quot;</code>)</code></li>
            <li><code class="code-voice"><code class="c">// prints &quot;theAceOfSpades: suit is ♠, value is 1 or 11&quot;</code></code></li>
        </ol>
      </div>
  </div>
  
</section><p class="para">A pesar de que <code class="code-voice">Rank</code> y <code class="code-voice">Suit</code> están anidados dentro de <code class="code-voice">BlackjackCard</code>, su tipo puede ser inferido a partir del contexto y así la inicialización de su instancia es capaz de referirse a los casos de la enumeración por sus nombres (<code class="code-voice">.Ace</code> y <code class="code-voice">.Spades</code>). En el ejemplo de arriba, la propiedad <code class="code-voice">description</code> informa correctamente que el As de Espadas tiene un valor de <code class="code-voice">1</code> u <code class="code-voice">11</code>.</p>
</section>
<section class="section">
	<a id="TP40016643-CH23-ID244">&#x200c;</a>
  
  <h3 class="section-name">Refiriéndose a Tipos Anidados</h3>
  <p class="para">Para usar un tipo anidado afuera de la definición de su contexto, prefija su nombre con el nombre del tipo en el que se encuentra anidado:</p><section class="code-listing">
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">heartsSymbol</code> = <code class="vc">BlackjackCard</code>.<code class="vc">Suit</code>.<code class="vc">Hearts</code>.<code class="vc">rawValue</code></code></li>
            <li><code class="code-voice"><code class="c">// heartsSymbol is &quot;♡&quot;</code></code></li>
        </ol>
      </div>
  </div>
  
</section><p class="para">Para el ejemplo de arriba, esto permite que los nombres de <code class="code-voice">Suit</code>, <code class="code-voice">Rank</code> y <code class="code-voice">Values</code> se mantengan deliberadamente cortos, porque sus nombres son naturalmente cualificados por su contexto en el cual ellos son definidos.</p>
</section>

  </article>
</div>

    </div>
  </body>
</html>
